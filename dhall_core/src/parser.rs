use pest::iterators::Pair;
use pest::Parser;
use std::collections::BTreeMap;
use std::path::PathBuf;
use std::rc::Rc;

use dhall_parser::{DhallParser, Rule};

use crate::core;
use crate::core::*;

// This file consumes the parse tree generated by pest and turns it into
// our own AST. All those custom macros should eventually moved into
// their own crate because they are quite general and useful. For now they
// are here and hopefully you can figure out how they work.

pub type ParsedExpr = Expr<X, Import>;
pub type ParsedText = InterpolatedText<X, Import>;
pub type ParsedTextContents<'a> = InterpolatedTextContents<'a, X, Import>;
pub type RcExpr = Rc<ParsedExpr>;

pub type ParseError = pest::error::Error<Rule>;

pub type ParseResult<T> = Result<T, ParseError>;

pub fn custom_parse_error(pair: &Pair<Rule>, msg: String) -> ParseError {
    let msg =
        format!("{} while matching on:\n{}", msg, debug_pair(pair.clone()));
    let e = pest::error::ErrorVariant::CustomError { message: msg };
    pest::error::Error::new_from_span(e, pair.as_span())
}

fn debug_pair(pair: Pair<Rule>) -> String {
    use std::fmt::Write;
    let mut s = String::new();
    fn aux(s: &mut String, indent: usize, prefix: String, pair: Pair<Rule>) {
        let indent_str = "| ".repeat(indent);
        let rule = pair.as_rule();
        let contents = pair.as_str();
        let mut inner = pair.into_inner();
        let mut first = true;
        while let Some(p) = inner.next() {
            if first {
                first = false;
                let last = inner.peek().is_none();
                if last && p.as_str() == contents {
                    let prefix = format!("{}{:?} > ", prefix, rule);
                    aux(s, indent, prefix, p);
                    continue;
                } else {
                    writeln!(
                        s,
                        r#"{}{}{:?}: "{}""#,
                        indent_str, prefix, rule, contents
                    )
                    .unwrap();
                }
            }
            aux(s, indent + 1, "".into(), p);
        }
        if first {
            writeln!(
                s,
                r#"{}{}{:?}: "{}""#,
                indent_str, prefix, rule, contents
            )
            .unwrap();
        }
    }
    aux(&mut s, 0, "".into(), pair);
    s
}

// #[derive(Debug)]
// enum IterMatchError<T> {
//     NoMatchFound,
//     Other(T), // Allow other macros to inject their own errors
// }

// macro_rules! match_iter_typed {
//     // Collect untyped arguments to pass to match_iter!
//     (@collect, ($($vars:tt)*), ($($args:tt)*), ($($acc:tt)*), ($x:ident : $ty:ident, $($rest:tt)*)) => {
//         match_iter_typed!(@collect, ($($vars)*), ($($args)*), ($($acc)*, $x), ($($rest)*))
//     };
//     (@collect, ($($vars:tt)*), ($($args:tt)*), ($($acc:tt)*), ($x:ident.. : $ty:ident, $($rest:tt)*)) => {
//         match_iter_typed!(@collect, ($($vars)*), ($($args)*), ($($acc)*, $x..), ($($rest)*))
//     };
//     // Catch extra comma if exists
//     (@collect, ($($vars:tt)*), ($($args:tt)*), (,$($acc:tt)*), ($(,)*)) => {
//         match_iter_typed!(@collect, ($($vars)*), ($($args)*), ($($acc)*), ())
//     };
//     (@collect, ($iter:expr, $body:expr, $callback:ident, $error:ident), ($($args:tt)*), ($($acc:tt)*), ($(,)*)) => {
//         {
//             let res = iter_patterns::destructure_iter!($iter; [$($acc)*] => {
//                 match_iter_typed!(@callback, $callback, $iter, $($args)*);
//                 $body
//             });
//             res.ok_or(IterMatchError::NoMatchFound)
//         }
//     };

//     // Pass the matches through the callback
//     (@callback, $callback:ident, $iter:expr, $x:ident : $ty:ident $($rest:tt)*) => {
//         let $x = $callback!(@type_callback, $ty, $x);
//         #[allow(unused_mut)]
//         let mut $x = match $x {
//             Ok(x) => x,
//             Err(e) => break Err(IterMatchError::Other(e)),
//         };
//         match_iter_typed!(@callback, $callback, $iter $($rest)*);
//     };
//     (@callback, $callback: ident, $iter:expr, $x:ident.. : $ty:ident $($rest:tt)*) => {
//         let $x = $x.map(|x| $callback!(@type_callback, $ty, x)).collect();
//         let $x: Vec<_> = match $x {
//             Ok(x) => x,
//             Err(e) => break Err(IterMatchError::Other(e)),
//         };
//         #[allow(unused_mut)]
//         let mut $x = $x.into_iter();
//         match_iter_typed!(@callback, $callback, $iter $($rest)*);
//     };
//     (@callback, $callback:ident, $iter:expr $(,)*) => {};

//     ($callback:ident; $iter:expr; ($($args:tt)*) => $body:expr) => {
//         {
//             #[allow(unused_mut)]
//             let mut iter = $iter;
//             let res: Result<_, IterMatchError<_>> = loop {
//                 break match_iter_typed!(@collect,
//                     (iter, $body, $callback, last_error),
//                     ($($args)*), (), ($($args)*,)
//                 )
//             };
//             res
//         }
//     };
// }

// macro_rules! match_iter_branching {
//     (@noclone, $callback:ident; $arg:expr; $( $submac:ident!($($args:tt)*) => $body:expr ),* $(,)*) => {
//         {
//             #[allow(unused_assignments)]
//             let mut last_error = IterMatchError::NoMatchFound;
//             // Not a real loop; used for error handling
//             // Would use loop labels but they create warnings
//             #[allow(unreachable_code)]
//             loop {
//                 $(
//                     let matched: Result<_, IterMatchError<_>> =
//                         $callback!(@branch_callback, $submac, $arg; ($($args)*) => $body);
//                     #[allow(unused_assignments)]
//                     match matched {
//                         Ok(v) => break Ok(v),
//                         Err(e) => last_error = e,
//                     };
//                 )*
//                 break Err(last_error);
//             }
//         }
//     };
//     ($callback:ident; $iter:expr; $($args:tt)*) => {
//         {
//             #[allow(unused_mut)]
//             let mut iter = $iter;
//             match_iter_branching!(@noclone, $callback; iter.clone(); $($args)*)
//         }
//     };
// }

macro_rules! match_pair {
    // // (@type_callback, parse_any_fast, $x:expr) => {
    // //     ParseWrapped::parse_any_fast($x).map(Box::new)
    // // };
    // (@type_callback, $ty:ident, $x:expr) => {
    //     ParseUnwrapped::$ty($x)
    //     // ParseWrapped::$ty($x).map(|x| x.$ty())
    //     // match ParseWrapped::parse_any($x) {
    //     // match parse_any_fast($x.clone()) {
    //     // // match ParseWrapped::$ty($x.clone()) {
    //     //     Ok(ParsedValue::$ty(x)) => Ok(x),
    //     //     // _ => ParseUnwrapped::$ty($x),
    //     //     _ => Err(custom_parse_error(&$x, format!("Total failure"))),
    //     // }
    // };
    // (@branch_callback, children, $pair:expr; $($args:tt)*) => {
    //     {
    //         #[allow(unused_mut)]
    //         let mut pairs = $pair.clone().into_inner();
    //         match_iter_typed!(match_pair; pairs; $($args)*)
    //     }
    // };
    // (@branch_callback, raw_pair, $pair:expr; ($x:ident) => $body:expr) => {
    //     {
    //         let $x = $pair.clone();
    //         Ok($body)
    //     }
    // };
    // (@branch_callback, captured_str, $pair:expr; ($x:ident) => $body:expr) => {
    //     {
    //         let $x = $pair.as_str();
    //         Ok($body)
    //     }
    // };

    (@make_child_match, $pair:expr, ($($outer_acc:tt)*), ($($acc:tt)*), ($(,)* $x:ident : $ty:ident $($rest_of_match:tt)*) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_child_match, $pair, ($($outer_acc)*), ($($acc)*, ParsedValue::$ty($x)), ($($rest_of_match)*) => $body, $($rest)*)
    };
    (@make_child_match, $pair:expr, ($($outer_acc:tt)*), ($($acc:tt)*), ($(,)* $x:ident.. : $ty:ident $($rest_of_match:tt)*) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_child_match, $pair, ($($outer_acc)*), ($($acc)*, x..), ($($rest_of_match)*) => {
            let $x = x.map(|x| x.$ty());
            $body
        }, $($rest)*)
    };
    (@make_child_match, $pair:expr, ($($outer_acc:tt)*), (, $($acc:tt)*), ($(,)*) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_matches, $pair, ([$($acc)*] => { $body }, $($outer_acc)*), $($rest)*)
    };
    (@make_child_match, $pair:expr, ($($outer_acc:tt)*), (), ($(,)*) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_matches, $pair, ([] => { $body }, $($outer_acc)*), $($rest)*)
    };

    (@make_matches, $pair:expr, ($($acc:tt)*), children!($($args:tt)*) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_child_match, $pair, ($($acc)*), (), ($($args)*) => $body, $($rest)*)
    // (@make_matches, $pair:expr, ($($acc:tt)*), children!($($x:ident : $ty:ident),*) => $body:expr, $($rest:tt)*) => {
        // match_pair!(@make_child_match, $pair, ($($acc)*), ($(, ParsedValue::$ty($x))*), () => $body, $($rest)*)
        // match_pair!(@make_matches, $pair, ([$(ParsedValue::$ty($x)),*] => { $body }, $($acc)*), $($rest)*)
    };
    (@make_matches, $pair:expr, ($($acc:tt)*), raw_pair!($x:ident) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_matches, $pair, ([..] => {
            let $x = $pair.clone();
            $body
        }, $($acc)*), $($rest)*)
    };
    (@make_matches, $pair:expr, ($($acc:tt)*), captured_str!($x:ident) => $body:expr, $($rest:tt)*) => {
        match_pair!(@make_matches, $pair, ([..] => {
            let $x = $pair.as_str();
            $body
        }, $($acc)*), $($rest)*)
    };
    (@make_matches, $pair:expr, ($($acc:tt)*) $(,)*) => {
        {
            let pair = $pair.clone();
            let rule = pair.as_rule();
            let parsed: Vec<_> = pair.clone().into_inner().map(ParseWrapped::parse_any_fast).collect::<Result<_, _>>()?;
            #[allow(unreachable_code)]
            iter_patterns::match_vec!(parsed;
                $($acc)*
                [x..] => panic!("Unexpected children while parsing rule '{:?}': {:?}", rule, x.collect::<Vec<_>>()),
            ).ok_or_else(|| custom_parse_error(&pair, "No match found".to_owned()))
        }
    };

    // ($pair:expr; $( children!($($x:ident : $ty:ident),*) => $body:expr ),* $(,)*) => {
    //     match_pair!(@make_matches, $pair, (), $( children!($($x : $ty),*) => $body ),* ,)
    // ($pair:expr; $( children!($($args:tt)*) => $body:expr ),* $(,)*) => {
    //     match_pair!(@make_matches, $pair, (), $( children!($($args)*) => $body ),* ,)
    ($pair:expr; $( $submac:ident!($($args:tt)*) => $body:expr ),* $(,)*) => {
        match_pair!(@make_matches, $pair, (), $( $submac!($($args)*) => $body ),* ,)
    // ($pair:expr; $($args:tt)*) => {
    //     match_pair!(@make_matches, $pair, (), $($args)*)
        // {
        //     let pair = $pair;
        //     let rule = pair.as_rule();
        //     let err = custom_parse_error(&pair, "No match found".to_owned());
        //     let parsed: Vec<_> = pair.into_inner().map(ParseWrapped::parse_any_fast).collect::<Result<_, _>>()?;
        //     #[allow(unreachable_code)]
        //     iter_patterns::match_vec!(parsed;
        //         $(
        //             [$(ParsedValue::$ty($x)),*] => { $body },
        //         )*
        //         [x..] => panic!("Unexpected children while parsing rule '{:?}': {:?}", rule, x.collect::<Vec<_>>()),
        //     ).ok_or(err)
        // }
    };
    ($pair:expr; $($args:tt)*) => {
        {
            let pair = $pair;
            let result = match_iter_branching!(@noclone, match_pair; pair; $($args)*);
            result.map_err(|e| match e {
                IterMatchError::Other(e) => e,
                _ => custom_parse_error(&pair, "No match found".to_owned()),
            })
        }
    };
}

macro_rules! make_parser {
    (@branch_rules, $pair:expr, ($($acc:tt)*), rule!( $name:ident<$o:ty>; $($args:tt)* ); $($rest:tt)*) => (
        make_parser!(@branch_rules, $pair, ($($acc)* Rule::$name => ParseWrapped::$name($pair),), $($rest)*)
    );
    (@branch_rules, $pair:expr, ($($acc:tt)*), rule_group!( $name:ident<$o:ty>; $($ty:ident),* ); $($rest:tt)*) => (
        make_parser!(@branch_rules, $pair, ($($acc)* $( Rule::$ty => ParseUnwrapped::$ty($pair).map(ParsedValue::$name),)* ), $($rest)*)
    );
    (@branch_rules, $pair:expr, ($($acc:tt)*), $submac:ident!( $name:ident<$o:ty>; $($args:tt)* ); $($rest:tt)*) => (
        make_parser!(@branch_rules, $pair, ($($acc)*), $($rest)*)
    );
    (@branch_rules, $pair:expr, ($($acc:tt)*),) => (
        #[allow(unreachable_patterns)]
        match $pair.as_rule() {
            $($acc)*
            r => Err(custom_parse_error(&$pair, format!("parse_any_fast: Unexpected {:?}", r))),
            // [x..] => panic!("{:?}", x.collect::<Vec<_>>()),
        }
    );
    ($( $submac:ident!( $name:ident<$o:ty>; $($args:tt)* ); )*) => (
        // #[allow(non_camel_case_types, dead_code)]
        // enum ParsedType {
        //     $( $name, )*
        // }

        // impl ParsedType {
        //     #[allow(dead_code)]
        //     fn parse(self, pair: Pair<Rule>) -> ParseResult<ParsedValue> {
        //         match self {
        //             $( ParsedType::$name => {
        //                 let ret = $name(pair)?;
        //                 Ok(ParsedValue::$name(ret))
        //             }, )*
        //         }
        //     }
        //     // fn parse(self, pair: Pair<Rule>) -> ParseResult<ParsedValue> {
        //     //     match self {
        //     //         $( ParsedType::$name => $name(pair), )*
        //     //     }
        //     // }
        // }
        struct ParseWrapped;
        struct ParseUnwrapped;

        #[allow(non_camel_case_types, dead_code)]
        #[derive(Debug)]
        enum ParsedValue<'a> {
            $( $name($o), )*
            // parse_any(Box<ParsedValue<'a>>),
        }

        impl<'a> ParsedValue<'a> {
            $(
                #[allow(non_snake_case, dead_code)]
                fn $name(self) -> $o {
                    match self {
                        ParsedValue::$name(x) => x,
                        _ => unreachable!(),
                    }
                }
            )*
            // #[allow(non_snake_case, dead_code)]
            // fn parse_any(self) -> Box<ParsedValue<'a>> {
            //     match self {
            //         ParsedValue::parse_any(x) => x,
            //         x => Box::new(x),
            //     }
            // }
            // #[allow(non_snake_case, dead_code)]
            // fn parse_any_fast(self) -> Box<ParsedValue<'a>> {
            //     self.parse_any()
            // }
        }

        // named!(parse_any<Box<ParsedValue<'a>>>;
        //     // self!(x: parse_any_fast) => x,
        //     $(
        //         self!(x: $name) => Box::new(ParsedValue::$name(x)),
        //     )*
        // );

        impl ParseWrapped {
            #[allow(non_snake_case, dead_code)]
            fn parse_any_fast(pair: Pair<Rule>) -> ParseResult<ParsedValue> {
                make_parser!(@branch_rules, pair, (), $( $submac!( $name<$o>; $($args)* ); )*)
            }
        }

        impl ParseUnwrapped {
            #[allow(unused_variables, non_snake_case, dead_code, clippy::all)]
            fn expression<'a>(pair: Pair<'a, Rule>) -> ParseResult<RcExpr> {
                ParseWrapped::expression(pair).map(|x| x.expression())
            }
        }
        impl ParseWrapped {
            #[allow(unused_variables, non_snake_case, dead_code, clippy::all)]
            fn expression<'a>(pair: Pair<'a, Rule>) -> ParseResult<ParsedValue<'a>> {
                ParseWrapped::parse_any_fast(pair)
            }
        }

        // fn do_the_parse(s: &str, r: Rule, ty: ParsedType) -> ParseResult<ParsedValue>  {
        //     let pairs = DhallParser::parse(r, s)?;
        //     match_iter!(pairs; (e) => ty.parse(e))
        // }

        $(
            $submac!($name<$o>; $($args)*);
        )*
    );
}

macro_rules! make_pest_parse_function {
    ($name:ident<$o:ty>; $submac:ident!( $($args:tt)* )) => (
        impl ParseUnwrapped {
            #[allow(unused_variables, non_snake_case, dead_code, clippy::all)]
            fn $name<'a>(pair: Pair<'a, Rule>) -> ParseResult<$o> {
                ParseWrapped::$name(pair).map(|x| x.$name())
            }
        }
        impl ParseWrapped {
            #[allow(unused_variables, non_snake_case, dead_code, clippy::all)]
            fn $name<'a>(pair: Pair<'a, Rule>) -> ParseResult<ParsedValue<'a>> {
                let res: ParseResult<$o> = $submac!(pair; $($args)*);
                Ok(ParsedValue::$name(res?))
            }
        }
    );
}

// macro_rules! named {
//     ($name:ident<$o:ty>; $($args:tt)*) => (
//         make_pest_parse_function!($name<$o>; match_pair!( $($args)* ));
//     );
// }

macro_rules! rule {
    ($name:ident<$o:ty>; $($args:tt)*) => (
        make_pest_parse_function!($name<$o>; match_pair!( $($args)* ));
        // make_pest_parse_function!($name<$o>; match_rule!(
        //     Rule::$name => match_pair!( $($args)* ),
        // ));
    );
}

macro_rules! rule_group {
    ($name:ident<$o:ty>; $($ty:ident),*) => (
        // make_pest_parse_function!($name<$o>; match_rule!(
        //     $(
        //         Rule::$ty => match_pair!(raw_pair!(p) => ParseUnwrapped::$ty(p)?),
        //     )*
        // ));
    );
}

// macro_rules! match_rule {
//     ($pair:expr; $($pat:pat => $submac:ident!( $($args:tt)* ),)*) => {
//         {
//             #[allow(unreachable_patterns)]
//             match $pair.as_rule() {
//                 $(
//                     $pat => $submac!($pair; $($args)*),
//                 )*
//                 r => Err(custom_parse_error(&$pair, format!("Unexpected {:?}", r))),
//             }
//         }
//     };
// }

// List of rules that can be shortcutted as implemented in binop!()
fn can_be_shortcutted(rule: Rule) -> bool {
    use Rule::*;
    match rule {
        import_alt_expression
        | or_expression
        | plus_expression
        | text_append_expression
        | list_append_expression
        | and_expression
        | combine_expression
        | prefer_expression
        | combine_types_expression
        | times_expression
        | equal_expression
        | not_equal_expression
        | application_expression
        | selector_expression_raw
        | annotated_expression => true,
        _ => false,
    }
}

macro_rules! binop {
    ($rule:ident<$ty:ty>; $op:ident) => {
        rule!($rule<$ty>;
            raw_pair!(pair) => {
                // This all could be a trivial fold, but to avoid stack explosion
                // we try to cut down on the recursion level here, by consuming
                // chains of blah_expression > ... > blih_expression in one go.
                let mut pair = pair;
                let mut pairs = pair.into_inner();
                let first = pairs.next().unwrap();
                let rest: Vec<_> = pairs.map(ParseUnwrapped::expression).collect::<Result<_, _>>()?;
                if !rest.is_empty() {
                    // If there is more than one subexpression, handle it normally
                    let first = ParseUnwrapped::expression(first)?;
                    rest.into_iter().fold(first, |acc, e| bx(Expr::BinOp(BinOp::$op, acc, e)))
                } else {
                    // Otherwise, consume short-cuttable rules as long as they contain only one subexpression.
                    // println!("short-cutting {}", debug_pair(pair.clone()));
                    pair = first;
                    while can_be_shortcutted(pair.as_rule()) {
                        let mut pairs = pair.clone().into_inner();
                        let first = pairs.next().unwrap();
                        let rest: Vec<_> = pairs.collect();
                        if !rest.is_empty() {
                            break;
                        }
                        pair = first;
                    }
                    // println!("short-cutted {}", debug_pair(pair.clone()));
                    // println!();
                    ParseUnwrapped::expression(pair)?
                }
            }
            // children!(first: expression, rest..: expression) => {
            //     rest.fold(first, |acc, e| bx(Expr::BinOp(BinOp::$op, acc, e)))
            // }
        );
    };
}

make_parser! {
rule!(EOI<()>; children!() => ());

// named!(str<&'a str>; captured_str!(s) => s.trim());

// named!(raw_str<&'a str>; captured_str!(s) => s);

// named!(label<Label>; captured_str!(s) => Label::from(s.trim().to_owned()));

rule!(label_raw<Label>; captured_str!(s) => Label::from(s.trim().to_owned()));

rule!(double_quote_literal<ParsedText>;
    children!(chunks..: double_quote_chunk) => {
        chunks.collect()
    }
);

rule!(double_quote_chunk<ParsedTextContents<'a>>;
    children!(c: interpolation) => {
        InterpolatedTextContents::Expr(c)
    },
    children!(s: double_quote_escaped) => {
        InterpolatedTextContents::Text(s)
    },
    children!(s: double_quote_char) => {
        InterpolatedTextContents::Text(s)
    },
);
rule!(double_quote_escaped<&'a str>;
    // TODO: parse all escapes
    captured_str!(s) => {
        match s {
            "\"" => "\"",
            "$" => "$",
            "\\" => "\\",
            "/" => "/",
            // "b" => "\b",
            // "f" => "\f",
            "n" => "\n",
            "r" => "\r",
            "t" => "\t",
            // "uXXXX"
            _ => unimplemented!(),
        }
    }
);
rule!(double_quote_char<&'a str>;
    captured_str!(s) => s
);

rule!(end_of_line<()>; children!() => ());

rule!(single_quote_literal<ParsedText>;
    children!(eol: end_of_line, contents: single_quote_continue) => {
        contents.into_iter().rev().collect::<ParsedText>()
    }
);
rule!(single_quote_char<&'a str>;
    captured_str!(s) => s
);
rule!(escaped_quote_pair<&'a str>;
    children!() => "''"
);
rule!(escaped_interpolation<&'a str>;
    children!() => "${"
);
rule!(interpolation<RcExpr>;
    children!(e: expression) => e
);

rule!(single_quote_continue<Vec<ParsedTextContents<'a>>>;
    children!(c: interpolation, rest: single_quote_continue) => {
        let mut rest = rest;
        rest.push(InterpolatedTextContents::Expr(c)); rest
    },
    children!(c: escaped_quote_pair, rest: single_quote_continue) => {
        let mut rest = rest;
        rest.push(InterpolatedTextContents::Text(c)); rest
    },
    children!(c: escaped_interpolation, rest: single_quote_continue) => {
        let mut rest = rest;
        rest.push(InterpolatedTextContents::Text(c)); rest
    },
    children!(c: single_quote_char, rest: single_quote_continue) => {
        let mut rest = rest;
        rest.push(InterpolatedTextContents::Text(c)); rest
    },
    children!() => {
        vec![]
    },
);

rule!(NaN_raw<()>; children!() => ());
rule!(minus_infinity_literal<()>; children!() => ());
rule!(plus_infinity_literal<()>; children!() => ());

rule!(double_literal_raw<core::Double>;
    raw_pair!(pair) => {
        pair.as_str().trim()
            .parse()
            .map_err(|e: std::num::ParseFloatError| custom_parse_error(&pair, format!("{}", e)))?
    }
);

rule!(natural_literal_raw<core::Natural>;
    raw_pair!(pair) => {
        pair.as_str().trim()
            .parse()
            .map_err(|e: std::num::ParseIntError| custom_parse_error(&pair, format!("{}", e)))?
    }
);

rule!(integer_literal_raw<core::Integer>;
    raw_pair!(pair) => {
        pair.as_str().trim()
            .parse()
            .map_err(|e: std::num::ParseIntError| custom_parse_error(&pair, format!("{}", e)))?
    }
);

rule!(path<PathBuf>;
    captured_str!(s) => (".".to_owned() + s).into()
);

rule_group!(local_raw<(FilePrefix, PathBuf)>;
    parent_path,
    here_path,
    home_path,
    absolute_path
);

rule!(parent_path<(FilePrefix, PathBuf)>;
    children!(p: path) => (FilePrefix::Parent, p)
);

rule!(here_path<(FilePrefix, PathBuf)>;
    children!(p: path) => (FilePrefix::Here, p)
);

rule!(home_path<(FilePrefix, PathBuf)>;
    children!(p: path) => (FilePrefix::Home, p)
);

rule!(absolute_path<(FilePrefix, PathBuf)>;
    children!(p: path) => (FilePrefix::Absolute, p)
);

// TODO: other import types
rule!(import_type_raw<ImportLocation>;
    // children!(_e: missing_raw) => {
    //     ImportLocation::Missing
    // }
    // children!(e: env_raw) => {
    //     ImportLocation::Env(e)
    // }
    // children!(url: http) => {
    //     ImportLocation::Remote(url)
    // }
    children!(import: local_raw) => {
        let (prefix, path) = import;
        ImportLocation::Local(prefix, path)
    }
);

rule!(import_hashed_raw<(ImportLocation, Option<()>)>;
    // TODO: handle hash
    children!(import: import_type_raw) => {
        (import, None)
    }
);

rule_group!(expression<RcExpr>;
    identifier_raw,
    lambda_expression,
    ifthenelse_expression,
    let_expression,
    forall_expression,
    arrow_expression,
    merge_expression,
    empty_collection,
    non_empty_optional,

    annotated_expression,
    import_alt_expression,
    or_expression,
    plus_expression,
    text_append_expression,
    list_append_expression,
    and_expression,
    combine_expression,
    prefer_expression,
    combine_types_expression,
    times_expression,
    equal_expression,
    not_equal_expression,
    application_expression,

    import_raw,
    selector_expression_raw,
    literal_expression_raw,
    empty_record_type,
    empty_record_literal,
    non_empty_record_type_or_literal,
    union_type_or_literal,
    non_empty_list_literal_raw,
    final_expression
);

rule!(import_raw<RcExpr>;
    // TODO: handle "as Text"
    children!(import: import_hashed_raw) => {
        let (location, hash) = import;
        bx(Expr::Embed(Import {
            mode: ImportMode::Code,
            hash,
            location,
        }))
    }
);

rule!(lambda_expression<RcExpr>;
    children!(l: label_raw, typ: expression, body: expression) => {
        bx(Expr::Lam(l, typ, body))
    }
);

rule!(ifthenelse_expression<RcExpr>;
    children!(cond: expression, left: expression, right: expression) => {
        bx(Expr::BoolIf(cond, left, right))
    }
);

rule!(let_expression<RcExpr>;
    children!(bindings..: let_binding, final_expr: expression) => {
        bindings.fold(final_expr, |acc, x| bx(Expr::Let(x.0, x.1, x.2, acc)))
    }
);

rule!(let_binding<(Label, Option<RcExpr>, RcExpr)>;
    children!(name: label_raw, annot: expression, expr: expression) => (name, Some(annot), expr),
    children!(name: label_raw, expr: expression) => (name, None, expr),
);

rule!(forall_expression<RcExpr>;
    children!(l: label_raw, typ: expression, body: expression) => {
        bx(Expr::Pi(l, typ, body))
    }
);

rule!(arrow_expression<RcExpr>;
    children!(typ: expression, body: expression) => {
        bx(Expr::Pi("_".into(), typ, body))
    }
);

rule!(merge_expression<RcExpr>;
    children!(x: expression, y: expression, z: expression) => bx(Expr::Merge(x, y, Some(z))),
    children!(x: expression, y: expression) => bx(Expr::Merge(x, y, None)),
);

rule!(List<()>; children!() => ());
rule!(Optional<()>; children!() => ());

rule!(empty_collection<RcExpr>;
    children!(_x: List, y: expression) => {
        bx(Expr::EmptyListLit(y))
    },
    children!(_x: Optional, y: expression) => {
        bx(Expr::OptionalLit(Some(y), None))
    },
);

rule!(non_empty_optional<RcExpr>;
    children!(x: expression, _y: Optional, z: expression) => {
        bx(Expr::OptionalLit(Some(z), Some(x)))
    }
);

binop!(import_alt_expression<RcExpr>; ImportAlt);
binop!(or_expression<RcExpr>; BoolOr);
binop!(plus_expression<RcExpr>; NaturalPlus);
binop!(text_append_expression<RcExpr>; TextAppend);
binop!(list_append_expression<RcExpr>; ListAppend);
binop!(and_expression<RcExpr>; BoolAnd);
binop!(combine_expression<RcExpr>; Combine);
binop!(prefer_expression<RcExpr>; Prefer);
binop!(combine_types_expression<RcExpr>; CombineTypes);
binop!(times_expression<RcExpr>; NaturalTimes);
binop!(equal_expression<RcExpr>; BoolEQ);
binop!(not_equal_expression<RcExpr>; BoolNE);

rule!(annotated_expression<RcExpr>;
    children!(e: expression, annot: expression) => {
        bx(Expr::Annot(e, annot))
    },
    children!(e: expression) => e,
);

rule!(application_expression<RcExpr>;
    children!(first: expression, rest..: expression) => {
        let rest: Vec<_> = rest.collect();
        if rest.is_empty() {
            first
        } else {
            bx(Expr::App(first, rest))
        }
    }
);

rule!(selector_expression_raw<RcExpr>;
    children!(first: expression, rest..: selector_raw) => {
        rest.fold(first, |acc, e| bx(Expr::Field(acc, e)))
    }
);

// TODO: handle record projection
rule!(selector_raw<Label>;
    children!(l: label_raw) => {
        l
    }
);

rule!(literal_expression_raw<RcExpr>;
    children!(n: double_literal_raw) => bx(Expr::DoubleLit(n)),
    children!(n: minus_infinity_literal) => bx(Expr::DoubleLit(std::f64::NEG_INFINITY)),
    children!(n: plus_infinity_literal) => bx(Expr::DoubleLit(std::f64::INFINITY)),
    children!(n: NaN_raw) => bx(Expr::DoubleLit(std::f64::NAN)),
    children!(n: natural_literal_raw) => bx(Expr::NaturalLit(n)),
    children!(n: integer_literal_raw) => bx(Expr::IntegerLit(n)),
    children!(s: double_quote_literal) => bx(Expr::TextLit(s)),
    children!(s: single_quote_literal) => bx(Expr::TextLit(s)),
    children!(e: expression) => e,
);

rule!(identifier_raw<RcExpr>;
    children!(l: label_raw, idx: natural_literal_raw) => {
        let name = String::from(l.clone());
        match Builtin::parse(name.as_str()) {
            Some(b) => bx(Expr::Builtin(b)),
            None => match name.as_str() {
                "True" => bx(Expr::BoolLit(true)),
                "False" => bx(Expr::BoolLit(false)),
                "Type" => bx(Expr::Const(Const::Type)),
                "Kind" => bx(Expr::Const(Const::Kind)),
                _ => bx(Expr::Var(V(l, idx))),
            }
        }
    },
    children!(l: label_raw) => {
        let name = String::from(l.clone());
        match Builtin::parse(name.as_str()) {
            Some(b) => bx(Expr::Builtin(b)),
            None => match name.as_str() {
                "True" => bx(Expr::BoolLit(true)),
                "False" => bx(Expr::BoolLit(false)),
                "Type" => bx(Expr::Const(Const::Type)),
                "Kind" => bx(Expr::Const(Const::Kind)),
                _ => bx(Expr::Var(V(l, 0))),
            }
        }
    },
);

rule!(empty_record_literal<RcExpr>;
    children!() => bx(Expr::RecordLit(BTreeMap::new()))
);

rule!(empty_record_type<RcExpr>;
    children!() => bx(Expr::Record(BTreeMap::new()))
);

rule!(non_empty_record_type_or_literal<RcExpr>;
    children!(first_label: label_raw, rest: non_empty_record_type) => {
        let (first_expr, mut map) = rest;
        map.insert(first_label, first_expr);
        bx(Expr::Record(map))
    },
    children!(first_label: label_raw, rest: non_empty_record_literal) => {
        let (first_expr, mut map) = rest;
        map.insert(first_label, first_expr);
        bx(Expr::RecordLit(map))
    },
);

rule!(non_empty_record_type<(RcExpr, BTreeMap<Label, RcExpr>)>;
    children!(expr: expression, entries..: record_type_entry) => {
        (expr, entries.collect())
    }
);

rule!(record_type_entry<(Label, RcExpr)>;
    children!(name: label_raw, expr: expression) => (name, expr)
);

rule!(non_empty_record_literal<(RcExpr, BTreeMap<Label, RcExpr>)>;
    children!(expr: expression, entries..: record_literal_entry) => {
        (expr, entries.collect())
    }
);

rule!(record_literal_entry<(Label, RcExpr)>;
    children!(name: label_raw, expr: expression) => (name, expr)
);

rule!(union_type_or_literal<RcExpr>;
    children!(_e: empty_union_type) => {
        bx(Expr::Union(BTreeMap::new()))
    },
    children!(x: non_empty_union_type_or_literal) => {
        match x {
            (Some((l, e)), entries) => bx(Expr::UnionLit(l, e, entries)),
            (None, entries) => bx(Expr::Union(entries)),
        }
    },
);

rule!(empty_union_type<()>; children!() => ());

rule!(non_empty_union_type_or_literal
      <(Option<(Label, RcExpr)>, BTreeMap<Label, RcExpr>)>;
    children!(l: label_raw, e: expression, entries: union_type_entries) => {
        (Some((l, e)), entries)
    },
    children!(l: label_raw, e: expression, rest: non_empty_union_type_or_literal) => {
        let (x, mut entries) = rest;
        entries.insert(l, e);
        (x, entries)
    },
    children!(l: label_raw, e: expression) => {
        let mut entries = BTreeMap::new();
        entries.insert(l, e);
        (None, entries)
    },
);

rule!(union_type_entries<BTreeMap<Label, RcExpr>>;
    children!(entries..: union_type_entry) => {
        entries.collect()
    }
);

rule!(union_type_entry<(Label, RcExpr)>;
    children!(name: label_raw, expr: expression) => (name, expr)
);

rule!(non_empty_list_literal_raw<RcExpr>;
    children!(items..: expression) => {
        bx(Expr::NEListLit(items.collect()))
    }
);

rule!(final_expression<RcExpr>;
    children!(e: expression, _eoi: EOI) => e
);
}

pub fn parse_expr(s: &str) -> ParseResult<RcExpr> {
    let pairs = DhallParser::parse(Rule::final_expression, s)?;
    // Match the only item in the pairs iterator
    // println!("{}", debug_pair(pairs.clone().next().unwrap()));
    let expr = iter_patterns::destructure_iter!(pairs; [p] => ParseUnwrapped::expression(p))
        .unwrap()?;
    // expr.expression()
    // Ok(expr.expression())
    Ok(expr)
    // Ok(bx(Expr::BoolLit(false)))
}

#[test]
fn test_parse() {
    // let expr = r#"{ x = "foo", y = 4 }.x"#;
    // let expr = r#"(1 + 2) * 3"#;
    let expr = r#"(1) + 3 * 5"#;
    println!("{:?}", parse_expr(expr));
    match parse_expr(expr) {
        Err(e) => {
            println!("{:?}", e);
            println!("{}", e);
        }
        ok => println!("{:?}", ok),
    };
    // assert!(false);
}
