use itertools::Itertools;
use pest::iterators::Pair;
use pest::prec_climber as pcl;
use pest::prec_climber::PrecClimber;
use pest::Parser;
use std::borrow::Cow;
use std::collections::HashMap;
use std::rc::Rc;

use dhall_generated_parser::{DhallParser, Rule};

use crate::map::{DupTreeMap, DupTreeSet};
use crate::ExprF::*;
use crate::*;

// This file consumes the parse tree generated by pest and turns it into
// our own AST. All those custom macros should eventually moved into
// their own crate because they are quite general and useful. For now they
// are here and hopefully you can figure out how they work.

pub(crate) type ParsedExpr = Expr<!>;
pub(crate) type ParsedSubExpr = SubExpr<!>;
type ParsedText = InterpolatedText<ParsedSubExpr>;
type ParsedTextContents = InterpolatedTextContents<ParsedSubExpr>;

pub type ParseError = pest::error::Error<Rule>;

pub type ParseResult<T> = Result<T, ParseError>;

#[derive(Debug)]
enum Either<A, B> {
    Left(A),
    Right(B),
}

impl crate::Builtin {
    pub fn parse(s: &str) -> Option<Self> {
        use crate::Builtin::*;
        match s {
            "Bool" => Some(Bool),
            "Natural" => Some(Natural),
            "Integer" => Some(Integer),
            "Double" => Some(Double),
            "Text" => Some(Text),
            "List" => Some(List),
            "Optional" => Some(Optional),
            "None" => Some(OptionalNone),
            "Natural/build" => Some(NaturalBuild),
            "Natural/fold" => Some(NaturalFold),
            "Natural/isZero" => Some(NaturalIsZero),
            "Natural/even" => Some(NaturalEven),
            "Natural/odd" => Some(NaturalOdd),
            "Natural/toInteger" => Some(NaturalToInteger),
            "Natural/show" => Some(NaturalShow),
            "Natural/subtract" => Some(NaturalSubtract),
            "Integer/toDouble" => Some(IntegerToDouble),
            "Integer/show" => Some(IntegerShow),
            "Double/show" => Some(DoubleShow),
            "List/build" => Some(ListBuild),
            "List/fold" => Some(ListFold),
            "List/length" => Some(ListLength),
            "List/head" => Some(ListHead),
            "List/last" => Some(ListLast),
            "List/indexed" => Some(ListIndexed),
            "List/reverse" => Some(ListReverse),
            "Optional/fold" => Some(OptionalFold),
            "Optional/build" => Some(OptionalBuild),
            "Text/show" => Some(TextShow),
            _ => None,
        }
    }
}

pub fn custom_parse_error(pair: &Pair<Rule>, msg: String) -> ParseError {
    let msg =
        format!("{} while matching on:\n{}", msg, debug_pair(pair.clone()));
    let e = pest::error::ErrorVariant::CustomError { message: msg };
    pest::error::Error::new_from_span(e, pair.as_span())
}

fn debug_pair(pair: Pair<Rule>) -> String {
    use std::fmt::Write;
    let mut s = String::new();
    fn aux(s: &mut String, indent: usize, prefix: String, pair: Pair<Rule>) {
        let indent_str = "| ".repeat(indent);
        let rule = pair.as_rule();
        let contents = pair.as_str();
        let mut inner = pair.into_inner();
        let mut first = true;
        while let Some(p) = inner.next() {
            if first {
                first = false;
                let last = inner.peek().is_none();
                if last && p.as_str() == contents {
                    let prefix = format!("{}{:?} > ", prefix, rule);
                    aux(s, indent, prefix, p);
                    continue;
                } else {
                    writeln!(
                        s,
                        r#"{}{}{:?}: "{}""#,
                        indent_str, prefix, rule, contents
                    )
                    .unwrap();
                }
            }
            aux(s, indent + 1, "".into(), p);
        }
        if first {
            writeln!(
                s,
                r#"{}{}{:?}: "{}""#,
                indent_str, prefix, rule, contents
            )
            .unwrap();
        }
    }
    aux(&mut s, 0, "".into(), pair);
    s
}

macro_rules! make_parser {
    (@pattern, rule, $name:ident) => (Rule::$name);
    (@pattern, token_rule, $name:ident) => (Rule::$name);
    (@pattern, rule_group, $name:ident) => (_);
    (@filter, rule) => (true);
    (@filter, token_rule) => (true);
    (@filter, rule_group) => (false);

    (@child_pattern,
        $varpat:ident,
        ($($acc:tt)*),
        [$variant:ident ($x:pat), $($rest:tt)*]
    ) => (
        make_parser!(@child_pattern,
            $varpat,
            ($($acc)* , Rule::$variant),
            [$($rest)*]
        )
    );
    (@child_pattern,
        $varpat:ident,
        ($($acc:tt)*),
        [$variant:ident ($x:ident).., $($rest:tt)*]
    ) => (
        make_parser!(@child_pattern,
            $varpat,
            ($($acc)* , $varpat..),
            [$($rest)*]
        )
    );
    (@child_pattern,
        $varpat:ident,
        (, $($acc:tt)*), [$(,)*]
    ) => ([$($acc)*]);
    (@child_pattern,
        $varpat:ident,
        ($($acc:tt)*), [$(,)*]
    ) => ([$($acc)*]);

    (@child_filter,
        $varpat:ident,
        [$variant:ident ($x:pat), $($rest:tt)*]
    ) => (
        true &&
        make_parser!(@child_filter, $varpat, [$($rest)*])
    );
    (@child_filter,
        $varpat:ident,
        [$variant:ident ($x:ident).., $($rest:tt)*]
    ) => (
        $varpat.iter().all(|r| r == &Rule::$variant) &&
        make_parser!(@child_filter, $varpat, [$($rest)*])
    );
    (@child_filter, $varpat:ident, [$(,)*]) => (true);

    (@rule_alias,
        rule!( $name:ident<$o:ty>; $($args:tt)* )
    ) => (
        Rule::$name
    );
    (@rule_alias,
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            $($args:tt)*
        )
    ) => ({
        Rule::$group
    });
    (@rule_alias,
        token_rule!($name:ident<$o:ty>)
    ) => ({
        Rule::$name
    });
    (@rule_alias, rule_group!( $name:ident<$o:ty> )) => (
        unreachable!()
    );

    (@body,
        ($climbers:expr, $input:expr, $pair:expr),
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            $span:ident;
            captured_str!($x:pat) => $body:expr
        )
    ) => ({
        let res: Result<_, String> = try {
            let $span = Span::make($input, $pair.as_span());
            let $x = $pair.as_str();
            ParsedValue::$group($body)
        };
        res.map_err(|msg| custom_parse_error(&$pair, msg))
    });
    (@body,
        ($climbers:expr, $input:expr, $pair:expr),
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            $span:ident;
            children!( $( [$($args:tt)*] => $body:expr ),* $(,)* )
        )
    ) => ({
        let children: Vec<_> = $pair
            .clone()
            .into_inner()
            .map(|p| parse_any($climbers, $input.clone(), p))
            .collect::<Result<_, _>>()?;
        let children_rules: Vec<Rule> = $pair
            .clone()
            .into_inner()
            .map(|p| p.as_rule())
            .map(rule_alias)
            .collect();

        #[allow(unreachable_code)]
        let res: Result<_, String> = try {
            #[allow(unused_imports)]
            use ParsedValue::*;
            let $span = Span::make($input, $pair.as_span());
            #[allow(unused_mut)]
            let mut iter = children.into_iter();

            match children_rules.as_slice() {
                $(
                    make_parser!(@child_pattern, x, (), [$($args)*,])
                    if make_parser!(@child_filter, x, [$($args)*,])
                    => {
                        let ret =
                            improved_slice_patterns::destructure_iter!(iter;
                                [$($args)*] => $body
                        );
                        match ret {
                            Some(x) => x,
                            None => Err({
                                format!("Unexpected children: {:?}", children_rules)
                            })?
                        }
                    }
                    ,
                )*
                [..] => Err({
                    format!("Unexpected children: {:?}", children_rules)
                })?,
            }
        };

        let res = res.map_err(|msg| custom_parse_error(&$pair, msg))?;
        Ok(ParsedValue::$group(res))
    });
    (@body,
        ($climbers:expr, $input:expr, $pair:expr),
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            prec_climb!( $_climber:expr, $args:pat => $body:expr $(,)* )
        )
    ) => ({
        let climber = $climbers.get(&Rule::$name).unwrap();
        climber.climb(
            $pair.clone().into_inner(),
            |p| parse_any($climbers, $input.clone(), p),
            |l, op, r| {
                let (l, r) = (l?, r?);
                let res: Result<_, String> = try {
                    #[allow(unused_imports)]
                    use ParsedValue::*;
                    match (l, op, r) {
                        $args => ParsedValue::$group($body),
                        children => Err(
                            format!("Unexpected children: {:?}", children)
                        )?,
                    }
                };
                res.map_err(|msg| custom_parse_error(&$pair, msg))
            },
        )
    });
    (@body,
        ($($things:tt)*),
        rule!( $name:ident<$o:ty>; $($args:tt)* )
    ) => (
        make_parser!(@body,
            ($($things)*),
            rule!( $name<$o> as $name; $($args)* )
        )
    );
    (@body,
        ($($things:tt)*),
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            $($args:tt)*
        )
    ) => ({
        make_parser!(@body,
            ($($things)*),
            rule!(
                $name<$o>
                as $group;
                _span;
                $($args)*
            )
        )
    });
    (@body,
        ($($things:tt)*),
        token_rule!($name:ident<$o:ty>)
    ) => ({
        Ok(ParsedValue::$name(()))
    });
    (@body, ($($things:tt)*), rule_group!( $name:ident<$o:ty> )) => (
        unreachable!()
    );

    (@construct_climber,
        ($map:expr),
        rule!(
            $name:ident<$o:ty>
            as $group:ident;
            prec_climb!( $climber:expr, $($_rest:tt)* )
        )
    ) => ({
        $map.insert(Rule::$name, $climber)
    });
    (@construct_climber, ($($things:tt)*), $($args:tt)*) => (());

    ($( $submac:ident!( $name:ident<$o:ty> $($args:tt)* ); )*) => (
        #[allow(non_camel_case_types, dead_code, clippy::large_enum_variant)]
        #[derive(Debug)]
        enum ParsedValue<'a> {
            $( $name($o), )*
        }

        fn construct_precclimbers() -> HashMap<Rule, PrecClimber<Rule>> {
            let mut map = HashMap::new();
            $(
                make_parser!(@construct_climber, (map),
                        $submac!( $name<$o> $($args)* ));
            )*
            map
        }

        struct Parsers;

        impl Parsers {
            $(
            #[allow(non_snake_case, unused_variables)]
            fn $name<'a>(
                climbers: &HashMap<Rule, PrecClimber<Rule>>,
                input: Rc<str>,
                pair: Pair<'a, Rule>,
            ) -> ParseResult<ParsedValue<'a>> {
                make_parser!(@body, (climbers, input, pair),
                               $submac!( $name<$o> $($args)* ))
            }
            )*
        }

        fn rule_alias(r: Rule) -> Rule {
            match r {
                $(
                    make_parser!(@pattern, $submac, $name)
                    if make_parser!(@filter, $submac)
                    => make_parser!(@rule_alias,
                                    $submac!( $name<$o> $($args)* ))
                    ,
                )*
                r => r,
            }
        }

        fn parse_any<'a>(
            climbers: &HashMap<Rule, PrecClimber<Rule>>,
            input: Rc<str>,
            mut pair: Pair<'a, Rule>,
        ) -> ParseResult<ParsedValue<'a>> {
            // Avoid parsing while the pair has exactly one child that can be returned as-is
            loop {
                if can_be_shortcutted(pair.as_rule()) {
                    let mut i = pair.clone().into_inner();
                    let first = i.next();
                    let second = i.next();
                    match (first, second) {
                        // If pair has exactly one child, just go on parsing that child
                        (Some(p), None) => {
                            pair = p;
                            continue;
                        }
                        // Otherwise parse normally
                        _ => break,
                    }
                }
                break;
            }

            match pair.as_rule() {
                $(
                    make_parser!(@pattern, $submac, $name)
                    if make_parser!(@filter, $submac)
                    => Parsers::$name(climbers, input, pair)
                    ,
                )*
                r => Err(custom_parse_error(&pair, format!("Unexpected {:?}", r))),
            }
        }
    );
}

fn do_parse<'a>(
    input: Rc<str>,
    pair: Pair<'a, Rule>,
) -> ParseResult<ParsedValue<'a>> {
    let climbers = construct_precclimbers();
    parse_any(&climbers, input, pair)
}

// List of rules that can be shortcutted if they have a single child
fn can_be_shortcutted(rule: Rule) -> bool {
    use Rule::*;
    match rule {
        expression
        | operator_expression
        | application_expression
        | first_application_expression
        | selector_expression
        | annotated_expression => true,
        _ => false,
    }
}

// Trim the shared indent off of a vec of lines, as defined by the Dhall semantics of multiline
// literals.
fn trim_indent(lines: &mut Vec<ParsedText>) {
    let is_indent = |c: char| c == ' ' || c == '\t';

    // There is at least one line so this is safe
    let last_line_head = lines.last().unwrap().head();
    let indent_chars = last_line_head
        .char_indices()
        .take_while(|(_, c)| is_indent(*c));
    let mut min_indent_idx = match indent_chars.last() {
        Some((i, _)) => i,
        // If there is no indent char, then no indent needs to be stripped
        None => return,
    };

    for line in lines.iter() {
        // Ignore empty lines
        if line.is_empty() {
            continue;
        }
        // Take chars from line while they match the current minimum indent.
        let indent_chars = last_line_head[0..=min_indent_idx]
            .char_indices()
            .zip(line.head().chars())
            .take_while(|((_, c1), c2)| c1 == c2);
        match indent_chars.last() {
            Some(((i, _), _)) => min_indent_idx = i,
            // If there is no indent char, then no indent needs to be stripped
            None => return,
        };
    }

    // Remove the shared indent from non-empty lines
    for line in lines.iter_mut() {
        if !line.is_empty() {
            line.head_mut().replace_range(0..=min_indent_idx, "");
        }
    }
}

make_parser! {
    token_rule!(EOI<()>);

    rule!(simple_label<Label>;
        captured_str!(s) => Label::from(s.trim().to_owned())
    );
    rule!(quoted_label<Label>;
        captured_str!(s) => Label::from(s.trim().to_owned())
    );
    rule!(label<Label>; children!(
        [simple_label(l)] => l,
        [quoted_label(l)] => l,
    ));

    rule!(double_quote_literal<ParsedText>; children!(
        [double_quote_chunk(chunks)..] => {
            chunks.collect()
        }
    ));

    rule!(double_quote_chunk<ParsedTextContents>; children!(
        [interpolation(e)] => {
            InterpolatedTextContents::Expr(e)
        },
        [double_quote_escaped(s)] => {
            InterpolatedTextContents::Text(s)
        },
        [double_quote_char(s)] => {
            InterpolatedTextContents::Text(s.to_owned())
        },
    ));
    rule!(double_quote_escaped<String>;
        captured_str!(s) => {
            match s {
                "\"" => "\"".to_owned(),
                "$" => "$".to_owned(),
                "\\" => "\\".to_owned(),
                "/" => "/".to_owned(),
                "b" => "\u{0008}".to_owned(),
                "f" => "\u{000C}".to_owned(),
                "n" => "\n".to_owned(),
                "r" => "\r".to_owned(),
                "t" => "\t".to_owned(),
                // "uXXXX" or "u{XXXXX}"
                _ => {
                    use std::convert::{TryFrom, TryInto};

                    let s = &s[1..];
                    let s = if &s[0..1] == "{" {
                        &s[1..s.len()-1]
                    } else {
                        &s[0..s.len()]
                    };

                    if s.len() > 8 {
                        Err(format!("Escape sequences can't have more than 8 chars: \"{}\"", s))?
                    }

                    // pad with zeroes
                    let s: String = std::iter::repeat('0')
                        .take(8 - s.len())
                        .chain(s.chars())
                        .collect();

                    // `s` has length 8, so `bytes` has length 4
                    let bytes: &[u8] = &hex::decode(s).unwrap();
                    let i = u32::from_be_bytes(bytes.try_into().unwrap());
                    let c = char::try_from(i).unwrap();
                    match i {
                        0xD800..=0xDFFF => {
                            let c_ecapsed = c.escape_unicode();
                            Err(format!("Escape sequences can't contain surrogate pairs: \"{}\"", c_ecapsed))?
                        },
                        0x0FFFE..=0x0FFFF | 0x1FFFE..=0x1FFFF |
                        0x2FFFE..=0x2FFFF | 0x3FFFE..=0x3FFFF |
                        0x4FFFE..=0x4FFFF | 0x5FFFE..=0x5FFFF |
                        0x6FFFE..=0x6FFFF | 0x7FFFE..=0x7FFFF |
                        0x8FFFE..=0x8FFFF | 0x9FFFE..=0x9FFFF |
                        0xAFFFE..=0xAFFFF | 0xBFFFE..=0xBFFFF |
                        0xCFFFE..=0xCFFFF | 0xDFFFE..=0xDFFFF |
                        0xEFFFE..=0xEFFFF | 0xFFFFE..=0xFFFFF |
                        0x10FFFE..=0x10FFFF => {
                            let c_ecapsed = c.escape_unicode();
                            Err(format!("Escape sequences can't contain non-characters: \"{}\"", c_ecapsed))?
                        },
                        _ => {}
                    }
                    std::iter::once(c).collect()
                }
            }
        }
    );
    rule!(double_quote_char<&'a str>;
        captured_str!(s) => s
    );

    rule!(single_quote_literal<ParsedText>; children!(
        [single_quote_continue(lines)] => {
            let newline: ParsedText = "\n".to_string().into();

            let mut lines: Vec<ParsedText> = lines
                .into_iter()
                .rev()
                .map(|l| l.into_iter().rev().collect::<ParsedText>())
                .collect();

            trim_indent(&mut lines);

            lines
                .into_iter()
                .intersperse(newline)
                .flat_map(InterpolatedText::into_iter)
                .collect::<ParsedText>()
        }
    ));
    rule!(single_quote_char<&'a str>;
        captured_str!(s) => s
    );
    rule!(escaped_quote_pair<&'a str> as single_quote_char;
        captured_str!(_) => "''"
    );
    rule!(escaped_interpolation<&'a str> as single_quote_char;
        captured_str!(_) => "${"
    );
    rule!(interpolation<ParsedSubExpr>; children!(
        [expression(e)] => e
    ));

    // Returns a vec of lines in reversed order, where each line is also in reversed order.
    rule!(single_quote_continue<Vec<Vec<ParsedTextContents>>>; children!(
        [interpolation(c), single_quote_continue(lines)] => {
            let c = InterpolatedTextContents::Expr(c);
            let mut lines = lines;
            lines.last_mut().unwrap().push(c);
            lines
        },
        [single_quote_char(c), single_quote_continue(lines)] => {
            let mut lines = lines;
            if c == "\n" || c == "\r\n" {
                lines.push(vec![]);
            } else {
                // TODO: don't allocate for every char
                let c = InterpolatedTextContents::Text(c.to_owned());
                lines.last_mut().unwrap().push(c);
            }
            lines
        },
        [] => {
            vec![vec![]]
        },
    ));

    rule!(builtin<ParsedSubExpr>; span;
        captured_str!(s) => {
            spanned(span, match crate::Builtin::parse(s) {
                Some(b) => Builtin(b),
                None => match s {
                    "True" => BoolLit(true),
                    "False" => BoolLit(false),
                    "Type" => Const(crate::Const::Type),
                    "Kind" => Const(crate::Const::Kind),
                    "Sort" => Const(crate::Const::Sort),
                    _ => Err(
                        format!("Unrecognized builtin: '{}'", s)
                    )?,
                }
            })
        }
    );

    token_rule!(NaN<()>);
    token_rule!(minus_infinity_literal<()>);
    token_rule!(plus_infinity_literal<()>);

    rule!(numeric_double_literal<core::Double>;
        captured_str!(s) => {
            let s = s.trim();
            match s.parse::<f64>() {
                Ok(x) if x.is_infinite() =>
                    Err(format!("Overflow while parsing double literal '{}'", s))?,
                Ok(x) => NaiveDouble::from(x),
                Err(e) => Err(format!("{}", e))?,
            }
        }
    );

    rule!(double_literal<core::Double>; children!(
        [numeric_double_literal(n)] => n,
        [minus_infinity_literal(n)] => std::f64::NEG_INFINITY.into(),
        [plus_infinity_literal(n)] => std::f64::INFINITY.into(),
        [NaN(n)] => std::f64::NAN.into(),
    ));

    rule!(natural_literal<core::Natural>;
        captured_str!(s) => {
            s.trim()
                .parse()
                .map_err(|e| format!("{}", e))?
        }
    );

    rule!(integer_literal<core::Integer>;
        captured_str!(s) => {
            s.trim()
                .parse()
                .map_err(|e| format!("{}", e))?
        }
    );

    rule!(identifier<ParsedSubExpr> as expression; span; children!(
        [variable(v)] => {
            spanned(span, Var(v))
        },
        [builtin(e)] => e,
    ));

    rule!(variable<V<Label>>; children!(
        [label(l), natural_literal(idx)] => {
            V(l, idx)
        },
        [label(l)] => {
            V(l, 0)
        },
    ));

    rule!(unquoted_path_component<&'a str>; captured_str!(s) => s);
    rule!(quoted_path_component<&'a str>; captured_str!(s) => s);
    rule!(path_component<String>; children!(
        [unquoted_path_component(s)] => {
            percent_encoding::percent_decode(s.as_bytes())
                .decode_utf8_lossy()
                .into_owned()
        },
        [quoted_path_component(s)] => s.to_string(),
    ));
    rule!(path<Vec<String>>; children!(
        [path_component(components)..] => {
            components.collect()
        }
    ));

    rule!(local<(FilePrefix, Vec<String>)>; children!(
        [local(l)] => l
    ));

    rule!(parent_path<(FilePrefix, Vec<String>)> as local; children!(
        [path(p)] => (FilePrefix::Parent, p)
    ));
    rule!(here_path<(FilePrefix, Vec<String>)> as local; children!(
        [path(p)] => (FilePrefix::Here, p)
    ));
    rule!(home_path<(FilePrefix, Vec<String>)> as local; children!(
        [path(p)] => (FilePrefix::Home, p)
    ));
    rule!(absolute_path<(FilePrefix, Vec<String>)> as local; children!(
        [path(p)] => (FilePrefix::Absolute, p)
    ));

    rule!(scheme<Scheme>; captured_str!(s) => match s {
        "http" => Scheme::HTTP,
        "https" => Scheme::HTTPS,
        _ => unreachable!(),
    });

    rule!(http_raw<URL<ParsedSubExpr>>; children!(
        [scheme(sch), authority(auth), path(p)] => URL {
            scheme: sch,
            authority: auth,
            path: p,
            query: None,
            headers: None,
        },
        [scheme(sch), authority(auth), path(p), query(q)] => URL {
            scheme: sch,
            authority: auth,
            path: p,
            query: Some(q),
            headers: None,
        },
    ));

    rule!(authority<String>; captured_str!(s) => s.to_owned());

    rule!(query<String>; captured_str!(s) => s.to_owned());

    rule!(http<URL<ParsedSubExpr>>; children!(
        [http_raw(url)] => url,
        [http_raw(url), expression(e)] =>
            URL { headers: Some(e), ..url },
    ));

    rule!(env<String>; children!(
        [bash_environment_variable(s)] => s,
        [posix_environment_variable(s)] => s,
    ));
    rule!(bash_environment_variable<String>; captured_str!(s) => s.to_owned());
    rule!(posix_environment_variable<String>; children!(
        [posix_environment_variable_character(chars)..] => {
            chars.collect()
        },
    ));
    rule!(posix_environment_variable_character<Cow<'a, str>>;
        captured_str!(s) => {
            match s {
                "\\\"" => Cow::Owned("\"".to_owned()),
                "\\\\" => Cow::Owned("\\".to_owned()),
                "\\a" =>  Cow::Owned("\u{0007}".to_owned()),
                "\\b" =>  Cow::Owned("\u{0008}".to_owned()),
                "\\f" =>  Cow::Owned("\u{000C}".to_owned()),
                "\\n" =>  Cow::Owned("\n".to_owned()),
                "\\r" =>  Cow::Owned("\r".to_owned()),
                "\\t" =>  Cow::Owned("\t".to_owned()),
                "\\v" =>  Cow::Owned("\u{000B}".to_owned()),
                _ => Cow::Borrowed(s)
            }
        }
    );

    token_rule!(missing<()>);

    rule!(import_type<ImportLocation<ParsedSubExpr>>; children!(
        [missing(_)] => {
            ImportLocation::Missing
        },
        [env(e)] => {
            ImportLocation::Env(e)
        },
        [http(url)] => {
            ImportLocation::Remote(url)
        },
        [local((prefix, p))] => {
            ImportLocation::Local(prefix, p)
        },
    ));

    rule!(hash<Hash>; captured_str!(s) => {
        let s = s.trim();
        let protocol = &s[..6];
        let hash = &s[7..];
        if protocol != "sha256" {
            Err(format!("Unknown hashing protocol '{}'", protocol))?
        }
        Hash::SHA256(hex::decode(hash).unwrap())
    });

    rule!(import_hashed<crate::Import<ParsedSubExpr>>; children!(
        [import_type(location)] =>
            crate::Import {mode: ImportMode::Code, location, hash: None },
        [import_type(location), hash(h)] =>
            crate::Import {mode: ImportMode::Code, location, hash: Some(h) },
    ));

    token_rule!(Text<()>);
    token_rule!(Location<()>);

    rule!(import<ParsedSubExpr> as expression; span; children!(
        [import_hashed(imp)] => {
            spanned(span, Import(crate::Import {
                mode: ImportMode::Code,
                ..imp
            }))
        },
        [import_hashed(imp), Text(_)] => {
            spanned(span, Import(crate::Import {
                mode: ImportMode::RawText,
                ..imp
            }))
        },
        [import_hashed(imp), Location(_)] => {
            spanned(span, Import(crate::Import {
                mode: ImportMode::Location,
                ..imp
            }))
        },
    ));

    token_rule!(lambda<()>);
    token_rule!(forall<()>);
    token_rule!(arrow<()>);
    token_rule!(merge<()>);
    token_rule!(assert<()>);
    token_rule!(if_<()>);
    token_rule!(in_<()>);

    rule!(empty_list_literal<ParsedSubExpr> as expression; span; children!(
        [expression(e)] => {
            spanned(span, EmptyListLit(e))
        },
    ));

    rule!(expression<ParsedSubExpr> as expression; span; children!(
        [lambda(()), label(l), expression(typ),
                arrow(()), expression(body)] => {
            spanned(span, Lam(l, typ, body))
        },
        [if_(()), expression(cond), expression(left), expression(right)] => {
            spanned(span, BoolIf(cond, left, right))
        },
        [let_binding(bindings).., in_(()), expression(final_expr)] => {
            bindings.rev().fold(
                final_expr,
                |acc, x| unspanned(Let(x.0, x.1, x.2, acc))
            )
        },
        [forall(()), label(l), expression(typ),
                arrow(()), expression(body)] => {
            spanned(span, Pi(l, typ, body))
        },
        [expression(typ), arrow(()), expression(body)] => {
            spanned(span, Pi("_".into(), typ, body))
        },
        [merge(()), expression(x), expression(y), expression(z)] => {
            spanned(span, Merge(x, y, Some(z)))
        },
        [assert(()), expression(x)] => {
            spanned(span, Assert(x))
        },
        [expression(e)] => e,
    ));

    rule!(let_binding<(Label, Option<ParsedSubExpr>, ParsedSubExpr)>;
            children!(
        [label(name), expression(annot), expression(expr)] =>
            (name, Some(annot), expr),
        [label(name), expression(expr)] =>
            (name, None, expr),
    ));

    token_rule!(List<()>);
    token_rule!(Optional<()>);

    rule!(annotated_expression<ParsedSubExpr> as expression; span; children!(
        [expression(e)] => e,
        [expression(e), expression(annot)] => {
            spanned(span, Annot(e, annot))
        },
    ));

    rule!(operator_expression<ParsedSubExpr> as expression; prec_climb!(
        {
            use Rule::*;
            // In order of precedence
            let operators = vec![
                import_alt,
                bool_or,
                natural_plus,
                text_append,
                list_append,
                bool_and,
                combine,
                prefer,
                combine_types,
                natural_times,
                bool_eq,
                bool_ne,
                equivalent,
            ];
            PrecClimber::new(
                operators
                    .into_iter()
                    .map(|op| pcl::Operator::new(op, pcl::Assoc::Left))
                    .collect(),
            )
        },
        (expression(l), op, expression(r)) => {
            use crate::BinOp::*;
            use Rule::*;
            let op = match op.as_rule() {
                import_alt => ImportAlt,
                bool_or => BoolOr,
                natural_plus => NaturalPlus,
                text_append => TextAppend,
                list_append => ListAppend,
                bool_and => BoolAnd,
                combine => RecursiveRecordMerge,
                prefer => RightBiasedRecordMerge,
                combine_types => RecursiveRecordTypeMerge,
                natural_times => NaturalTimes,
                bool_eq => BoolEQ,
                bool_ne => BoolNE,
                equivalent => Equivalence,
                r => Err(
                    format!("Rule {:?} isn't an operator", r),
                )?,
            };

            unspanned(BinOp(op, l, r))
        }
    ));

    token_rule!(Some_<()>);
    token_rule!(toMap<()>);

    rule!(application_expression<ParsedSubExpr> as expression; children!(
        [expression(e)] => e,
        [expression(first), expression(rest)..] => {
            rest.fold(first, |acc, e| unspanned(App(acc, e)))
        },
    ));

    rule!(first_application_expression<ParsedSubExpr> as expression; span;
            children!(
        [expression(e)] => e,
        [Some_(()), expression(e)] => {
            spanned(span, SomeLit(e))
        },
        [merge(()), expression(x), expression(y)] => {
            spanned(span, Merge(x, y, None))
        },
    ));

    rule!(selector_expression<ParsedSubExpr> as expression; children!(
        [expression(e)] => e,
        [expression(first), selector(rest)..] => {
            rest.fold(first, |acc, e| unspanned(match e {
                Either::Left(l) => Field(acc, l),
                Either::Right(ls) => Projection(acc, ls),
            }))
        }
    ));

    rule!(selector<Either<Label, DupTreeSet<Label>>>; children!(
        [label(l)] => Either::Left(l),
        [labels(ls)] => Either::Right(ls),
        [expression(e)] => unimplemented!("selection by expression"), // TODO
    ));

    rule!(labels<DupTreeSet<Label>>; children!(
        [label(ls)..] => ls.collect(),
    ));

    rule!(primitive_expression<ParsedSubExpr> as expression; span; children!(
        [double_literal(n)] => spanned(span, DoubleLit(n)),
        [natural_literal(n)] => spanned(span, NaturalLit(n)),
        [integer_literal(n)] => spanned(span, IntegerLit(n)),
        [double_quote_literal(s)] => spanned(span, TextLit(s)),
        [single_quote_literal(s)] => spanned(span, TextLit(s)),
        [expression(e)] => e,
    ));

    rule!(empty_record_literal<ParsedSubExpr> as expression; span;
        captured_str!(_) => spanned(span, RecordLit(Default::default()))
    );

    rule!(empty_record_type<ParsedSubExpr> as expression; span;
        captured_str!(_) => spanned(span, RecordType(Default::default()))
    );

    rule!(non_empty_record_type_or_literal<ParsedSubExpr> as expression; span;
          children!(
        [label(first_label), non_empty_record_type(rest)] => {
            let (first_expr, mut map) = rest;
            map.insert(first_label, first_expr);
            spanned(span, RecordType(map))
        },
        [label(first_label), non_empty_record_literal(rest)] => {
            let (first_expr, mut map) = rest;
            map.insert(first_label, first_expr);
            spanned(span, RecordLit(map))
        },
    ));

    rule!(non_empty_record_type
          <(ParsedSubExpr, DupTreeMap<Label, ParsedSubExpr>)>; children!(
        [expression(expr), record_type_entry(entries)..] => {
            (expr, entries.collect())
        }
    ));

    rule!(record_type_entry<(Label, ParsedSubExpr)>; children!(
        [label(name), expression(expr)] => (name, expr)
    ));

    rule!(non_empty_record_literal
          <(ParsedSubExpr, DupTreeMap<Label, ParsedSubExpr>)>; children!(
        [expression(expr), record_literal_entry(entries)..] => {
            (expr, entries.collect())
        }
    ));

    rule!(record_literal_entry<(Label, ParsedSubExpr)>; children!(
        [label(name), expression(expr)] => (name, expr)
    ));

    rule!(union_type<ParsedSubExpr> as expression; span; children!(
        [empty_union_type(_)] => {
            spanned(span, UnionType(Default::default()))
        },
        [union_type_entry(entries)..] => {
            spanned(span, UnionType(entries.collect()))
        },
    ));

    token_rule!(empty_union_type<()>);

    rule!(union_type_entry<(Label, Option<ParsedSubExpr>)>; children!(
        [label(name), expression(expr)] => (name, Some(expr)),
        [label(name)] => (name, None),
    ));

    rule!(non_empty_list_literal<ParsedSubExpr> as expression; span;
          children!(
        [expression(items)..] => spanned(
            span,
            NEListLit(items.collect())
        )
    ));

    rule!(final_expression<ParsedSubExpr> as expression; children!(
        [expression(e), EOI(_eoi)] => e
    ));
}

pub fn parse_expr(s: &str) -> ParseResult<ParsedSubExpr> {
    let mut pairs = DhallParser::parse(Rule::final_expression, s)?;
    let rc_input = s.to_string().into();
    let expr = do_parse(rc_input, pairs.next().unwrap())?;
    assert_eq!(pairs.next(), None);
    match expr {
        ParsedValue::expression(e) => Ok(e),
        _ => unreachable!(),
    }
}
